// Code generated by mockery. DO NOT EDIT.

package cache

import (
	context "context"

	cache "github.com/goravel/framework/contracts/cache"

	docker "github.com/goravel/framework/contracts/testing/docker"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// Add provides a mock function with given fields: key, value, t
func (_m *Repository) Add(key string, value interface{}, t time.Duration) bool {
	ret := _m.Called(key, value, t)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) bool); ok {
		r0 = rf(key, value, t)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Repository_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type Repository_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - key string
//   - value interface{}
//   - t time.Duration
func (_e *Repository_Expecter) Add(key interface{}, value interface{}, t interface{}) *Repository_Add_Call {
	return &Repository_Add_Call{Call: _e.mock.On("Add", key, value, t)}
}

func (_c *Repository_Add_Call) Run(run func(key string, value interface{}, t time.Duration)) *Repository_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(time.Duration))
	})
	return _c
}

func (_c *Repository_Add_Call) Return(_a0 bool) *Repository_Add_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Add_Call) RunAndReturn(run func(string, interface{}, time.Duration) bool) *Repository_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Decrement provides a mock function with given fields: key, value
func (_m *Repository) Decrement(key string, value ...int64) (int64, error) {
	_va := make([]interface{}, len(value))
	for _i := range value {
		_va[_i] = value[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Decrement")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...int64) (int64, error)); ok {
		return rf(key, value...)
	}
	if rf, ok := ret.Get(0).(func(string, ...int64) int64); ok {
		r0 = rf(key, value...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, ...int64) error); ok {
		r1 = rf(key, value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_Decrement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decrement'
type Repository_Decrement_Call struct {
	*mock.Call
}

// Decrement is a helper method to define mock.On call
//   - key string
//   - value ...int64
func (_e *Repository_Expecter) Decrement(key interface{}, value ...interface{}) *Repository_Decrement_Call {
	return &Repository_Decrement_Call{Call: _e.mock.On("Decrement",
		append([]interface{}{key}, value...)...)}
}

func (_c *Repository_Decrement_Call) Run(run func(key string, value ...int64)) *Repository_Decrement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Decrement_Call) Return(_a0 int64, _a1 error) *Repository_Decrement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_Decrement_Call) RunAndReturn(run func(string, ...int64) (int64, error)) *Repository_Decrement_Call {
	_c.Call.Return(run)
	return _c
}

// Docker provides a mock function with no fields
func (_m *Repository) Docker() (docker.CacheDriver, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Docker")
	}

	var r0 docker.CacheDriver
	var r1 error
	if rf, ok := ret.Get(0).(func() (docker.CacheDriver, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() docker.CacheDriver); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(docker.CacheDriver)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_Docker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Docker'
type Repository_Docker_Call struct {
	*mock.Call
}

// Docker is a helper method to define mock.On call
func (_e *Repository_Expecter) Docker() *Repository_Docker_Call {
	return &Repository_Docker_Call{Call: _e.mock.On("Docker")}
}

func (_c *Repository_Docker_Call) Run(run func()) *Repository_Docker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Repository_Docker_Call) Return(_a0 docker.CacheDriver, _a1 error) *Repository_Docker_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_Docker_Call) RunAndReturn(run func() (docker.CacheDriver, error)) *Repository_Docker_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function with no fields
func (_m *Repository) Flush() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Repository_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type Repository_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *Repository_Expecter) Flush() *Repository_Flush_Call {
	return &Repository_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *Repository_Flush_Call) Run(run func()) *Repository_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Repository_Flush_Call) Return(_a0 bool) *Repository_Flush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Flush_Call) RunAndReturn(run func() bool) *Repository_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// Forever provides a mock function with given fields: key, value
func (_m *Repository) Forever(key string, value interface{}) bool {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Forever")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, interface{}) bool); ok {
		r0 = rf(key, value)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Repository_Forever_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Forever'
type Repository_Forever_Call struct {
	*mock.Call
}

// Forever is a helper method to define mock.On call
//   - key string
//   - value interface{}
func (_e *Repository_Expecter) Forever(key interface{}, value interface{}) *Repository_Forever_Call {
	return &Repository_Forever_Call{Call: _e.mock.On("Forever", key, value)}
}

func (_c *Repository_Forever_Call) Run(run func(key string, value interface{})) *Repository_Forever_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Repository_Forever_Call) Return(_a0 bool) *Repository_Forever_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Forever_Call) RunAndReturn(run func(string, interface{}) bool) *Repository_Forever_Call {
	_c.Call.Return(run)
	return _c
}

// Forget provides a mock function with given fields: key
func (_m *Repository) Forget(key string) bool {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Forget")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Repository_Forget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Forget'
type Repository_Forget_Call struct {
	*mock.Call
}

// Forget is a helper method to define mock.On call
//   - key string
func (_e *Repository_Expecter) Forget(key interface{}) *Repository_Forget_Call {
	return &Repository_Forget_Call{Call: _e.mock.On("Forget", key)}
}

func (_c *Repository_Forget_Call) Run(run func(key string)) *Repository_Forget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Repository_Forget_Call) Return(_a0 bool) *Repository_Forget_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Forget_Call) RunAndReturn(run func(string) bool) *Repository_Forget_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: key, def
func (_m *Repository) Get(key string, def ...interface{}) interface{} {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, def...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(key, def...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Repository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Repository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key string
//   - def ...interface{}
func (_e *Repository_Expecter) Get(key interface{}, def ...interface{}) *Repository_Get_Call {
	return &Repository_Get_Call{Call: _e.mock.On("Get",
		append([]interface{}{key}, def...)...)}
}

func (_c *Repository_Get_Call) Run(run func(key string, def ...interface{})) *Repository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Get_Call) Return(_a0 interface{}) *Repository_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Get_Call) RunAndReturn(run func(string, ...interface{}) interface{}) *Repository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetBool provides a mock function with given fields: key, def
func (_m *Repository) GetBool(key string, def ...bool) bool {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBool")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, ...bool) bool); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Repository_GetBool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBool'
type Repository_GetBool_Call struct {
	*mock.Call
}

// GetBool is a helper method to define mock.On call
//   - key string
//   - def ...bool
func (_e *Repository_Expecter) GetBool(key interface{}, def ...interface{}) *Repository_GetBool_Call {
	return &Repository_GetBool_Call{Call: _e.mock.On("GetBool",
		append([]interface{}{key}, def...)...)}
}

func (_c *Repository_GetBool_Call) Run(run func(key string, def ...bool)) *Repository_GetBool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_GetBool_Call) Return(_a0 bool) *Repository_GetBool_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_GetBool_Call) RunAndReturn(run func(string, ...bool) bool) *Repository_GetBool_Call {
	_c.Call.Return(run)
	return _c
}

// GetInt provides a mock function with given fields: key, def
func (_m *Repository) GetInt(key string, def ...int) int {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInt")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func(string, ...int) int); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Repository_GetInt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInt'
type Repository_GetInt_Call struct {
	*mock.Call
}

// GetInt is a helper method to define mock.On call
//   - key string
//   - def ...int
func (_e *Repository_Expecter) GetInt(key interface{}, def ...interface{}) *Repository_GetInt_Call {
	return &Repository_GetInt_Call{Call: _e.mock.On("GetInt",
		append([]interface{}{key}, def...)...)}
}

func (_c *Repository_GetInt_Call) Run(run func(key string, def ...int)) *Repository_GetInt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_GetInt_Call) Return(_a0 int) *Repository_GetInt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_GetInt_Call) RunAndReturn(run func(string, ...int) int) *Repository_GetInt_Call {
	_c.Call.Return(run)
	return _c
}

// GetInt64 provides a mock function with given fields: key, def
func (_m *Repository) GetInt64(key string, def ...int64) int64 {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInt64")
	}

	var r0 int64
	if rf, ok := ret.Get(0).(func(string, ...int64) int64); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// Repository_GetInt64_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInt64'
type Repository_GetInt64_Call struct {
	*mock.Call
}

// GetInt64 is a helper method to define mock.On call
//   - key string
//   - def ...int64
func (_e *Repository_Expecter) GetInt64(key interface{}, def ...interface{}) *Repository_GetInt64_Call {
	return &Repository_GetInt64_Call{Call: _e.mock.On("GetInt64",
		append([]interface{}{key}, def...)...)}
}

func (_c *Repository_GetInt64_Call) Run(run func(key string, def ...int64)) *Repository_GetInt64_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_GetInt64_Call) Return(_a0 int64) *Repository_GetInt64_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_GetInt64_Call) RunAndReturn(run func(string, ...int64) int64) *Repository_GetInt64_Call {
	_c.Call.Return(run)
	return _c
}

// GetString provides a mock function with given fields: key, def
func (_m *Repository) GetString(key string, def ...string) string {
	_va := make([]interface{}, len(def))
	for _i := range def {
		_va[_i] = def[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetString")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, ...string) string); ok {
		r0 = rf(key, def...)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Repository_GetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetString'
type Repository_GetString_Call struct {
	*mock.Call
}

// GetString is a helper method to define mock.On call
//   - key string
//   - def ...string
func (_e *Repository_Expecter) GetString(key interface{}, def ...interface{}) *Repository_GetString_Call {
	return &Repository_GetString_Call{Call: _e.mock.On("GetString",
		append([]interface{}{key}, def...)...)}
}

func (_c *Repository_GetString_Call) Run(run func(key string, def ...string)) *Repository_GetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_GetString_Call) Return(_a0 string) *Repository_GetString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_GetString_Call) RunAndReturn(run func(string, ...string) string) *Repository_GetString_Call {
	_c.Call.Return(run)
	return _c
}

// Has provides a mock function with given fields: key
func (_m *Repository) Has(key string) bool {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Has")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Repository_Has_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Has'
type Repository_Has_Call struct {
	*mock.Call
}

// Has is a helper method to define mock.On call
//   - key string
func (_e *Repository_Expecter) Has(key interface{}) *Repository_Has_Call {
	return &Repository_Has_Call{Call: _e.mock.On("Has", key)}
}

func (_c *Repository_Has_Call) Run(run func(key string)) *Repository_Has_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Repository_Has_Call) Return(_a0 bool) *Repository_Has_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Has_Call) RunAndReturn(run func(string) bool) *Repository_Has_Call {
	_c.Call.Return(run)
	return _c
}

// Increment provides a mock function with given fields: key, value
func (_m *Repository) Increment(key string, value ...int64) (int64, error) {
	_va := make([]interface{}, len(value))
	for _i := range value {
		_va[_i] = value[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Increment")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...int64) (int64, error)); ok {
		return rf(key, value...)
	}
	if rf, ok := ret.Get(0).(func(string, ...int64) int64); ok {
		r0 = rf(key, value...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(string, ...int64) error); ok {
		r1 = rf(key, value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_Increment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Increment'
type Repository_Increment_Call struct {
	*mock.Call
}

// Increment is a helper method to define mock.On call
//   - key string
//   - value ...int64
func (_e *Repository_Expecter) Increment(key interface{}, value ...interface{}) *Repository_Increment_Call {
	return &Repository_Increment_Call{Call: _e.mock.On("Increment",
		append([]interface{}{key}, value...)...)}
}

func (_c *Repository_Increment_Call) Run(run func(key string, value ...int64)) *Repository_Increment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Increment_Call) Return(_a0 int64, _a1 error) *Repository_Increment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_Increment_Call) RunAndReturn(run func(string, ...int64) (int64, error)) *Repository_Increment_Call {
	_c.Call.Return(run)
	return _c
}

// Lock provides a mock function with given fields: key, t
func (_m *Repository) Lock(key string, t ...time.Duration) cache.Lock {
	_va := make([]interface{}, len(t))
	for _i := range t {
		_va[_i] = t[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 cache.Lock
	if rf, ok := ret.Get(0).(func(string, ...time.Duration) cache.Lock); ok {
		r0 = rf(key, t...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Lock)
		}
	}

	return r0
}

// Repository_Lock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Lock'
type Repository_Lock_Call struct {
	*mock.Call
}

// Lock is a helper method to define mock.On call
//   - key string
//   - t ...time.Duration
func (_e *Repository_Expecter) Lock(key interface{}, t ...interface{}) *Repository_Lock_Call {
	return &Repository_Lock_Call{Call: _e.mock.On("Lock",
		append([]interface{}{key}, t...)...)}
}

func (_c *Repository_Lock_Call) Run(run func(key string, t ...time.Duration)) *Repository_Lock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]time.Duration, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(time.Duration)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Lock_Call) Return(_a0 cache.Lock) *Repository_Lock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Lock_Call) RunAndReturn(run func(string, ...time.Duration) cache.Lock) *Repository_Lock_Call {
	_c.Call.Return(run)
	return _c
}

// Many provides a mock function with given fields: keys
func (_m *Repository) Many(keys []string) map[string]interface{} {
	ret := _m.Called(keys)

	if len(ret) == 0 {
		panic("no return value specified for Many")
	}

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func([]string) map[string]interface{}); ok {
		r0 = rf(keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	return r0
}

// Repository_Many_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Many'
type Repository_Many_Call struct {
	*mock.Call
}

// Many is a helper method to define mock.On call
//   - keys []string
func (_e *Repository_Expecter) Many(keys interface{}) *Repository_Many_Call {
	return &Repository_Many_Call{Call: _e.mock.On("Many", keys)}
}

func (_c *Repository_Many_Call) Run(run func(keys []string)) *Repository_Many_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string))
	})
	return _c
}

func (_c *Repository_Many_Call) Return(_a0 map[string]interface{}) *Repository_Many_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Many_Call) RunAndReturn(run func([]string) map[string]interface{}) *Repository_Many_Call {
	_c.Call.Return(run)
	return _c
}

// Pull provides a mock function with given fields: key, def
func (_m *Repository) Pull(key string, def ...interface{}) interface{} {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, def...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Pull")
	}

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) interface{}); ok {
		r0 = rf(key, def...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// Repository_Pull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pull'
type Repository_Pull_Call struct {
	*mock.Call
}

// Pull is a helper method to define mock.On call
//   - key string
//   - def ...interface{}
func (_e *Repository_Expecter) Pull(key interface{}, def ...interface{}) *Repository_Pull_Call {
	return &Repository_Pull_Call{Call: _e.mock.On("Pull",
		append([]interface{}{key}, def...)...)}
}

func (_c *Repository_Pull_Call) Run(run func(key string, def ...interface{})) *Repository_Pull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Pull_Call) Return(_a0 interface{}) *Repository_Pull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Pull_Call) RunAndReturn(run func(string, ...interface{}) interface{}) *Repository_Pull_Call {
	_c.Call.Return(run)
	return _c
}

// Put provides a mock function with given fields: key, value, t
func (_m *Repository) Put(key string, value interface{}, t time.Duration) error {
	ret := _m.Called(key, value, t)

	if len(ret) == 0 {
		panic("no return value specified for Put")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) error); ok {
		r0 = rf(key, value, t)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_Put_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Put'
type Repository_Put_Call struct {
	*mock.Call
}

// Put is a helper method to define mock.On call
//   - key string
//   - value interface{}
//   - t time.Duration
func (_e *Repository_Expecter) Put(key interface{}, value interface{}, t interface{}) *Repository_Put_Call {
	return &Repository_Put_Call{Call: _e.mock.On("Put", key, value, t)}
}

func (_c *Repository_Put_Call) Run(run func(key string, value interface{}, t time.Duration)) *Repository_Put_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(time.Duration))
	})
	return _c
}

func (_c *Repository_Put_Call) Return(_a0 error) *Repository_Put_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Put_Call) RunAndReturn(run func(string, interface{}, time.Duration) error) *Repository_Put_Call {
	_c.Call.Return(run)
	return _c
}

// PutMany provides a mock function with given fields: values, t
func (_m *Repository) PutMany(values map[string]interface{}, t time.Duration) error {
	ret := _m.Called(values, t)

	if len(ret) == 0 {
		panic("no return value specified for PutMany")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, time.Duration) error); ok {
		r0 = rf(values, t)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_PutMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutMany'
type Repository_PutMany_Call struct {
	*mock.Call
}

// PutMany is a helper method to define mock.On call
//   - values map[string]interface{}
//   - t time.Duration
func (_e *Repository_Expecter) PutMany(values interface{}, t interface{}) *Repository_PutMany_Call {
	return &Repository_PutMany_Call{Call: _e.mock.On("PutMany", values, t)}
}

func (_c *Repository_PutMany_Call) Run(run func(values map[string]interface{}, t time.Duration)) *Repository_PutMany_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}), args[1].(time.Duration))
	})
	return _c
}

func (_c *Repository_PutMany_Call) Return(_a0 error) *Repository_PutMany_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_PutMany_Call) RunAndReturn(run func(map[string]interface{}, time.Duration) error) *Repository_PutMany_Call {
	_c.Call.Return(run)
	return _c
}

// Remember provides a mock function with given fields: key, ttl, callback
func (_m *Repository) Remember(key string, ttl time.Duration, callback func() (interface{}, error)) (interface{}, error) {
	ret := _m.Called(key, ttl, callback)

	if len(ret) == 0 {
		panic("no return value specified for Remember")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, time.Duration, func() (interface{}, error)) (interface{}, error)); ok {
		return rf(key, ttl, callback)
	}
	if rf, ok := ret.Get(0).(func(string, time.Duration, func() (interface{}, error)) interface{}); ok {
		r0 = rf(key, ttl, callback)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, time.Duration, func() (interface{}, error)) error); ok {
		r1 = rf(key, ttl, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_Remember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remember'
type Repository_Remember_Call struct {
	*mock.Call
}

// Remember is a helper method to define mock.On call
//   - key string
//   - ttl time.Duration
//   - callback func()(interface{} , error)
func (_e *Repository_Expecter) Remember(key interface{}, ttl interface{}, callback interface{}) *Repository_Remember_Call {
	return &Repository_Remember_Call{Call: _e.mock.On("Remember", key, ttl, callback)}
}

func (_c *Repository_Remember_Call) Run(run func(key string, ttl time.Duration, callback func() (interface{}, error))) *Repository_Remember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration), args[2].(func() (interface{}, error)))
	})
	return _c
}

func (_c *Repository_Remember_Call) Return(_a0 interface{}, _a1 error) *Repository_Remember_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_Remember_Call) RunAndReturn(run func(string, time.Duration, func() (interface{}, error)) (interface{}, error)) *Repository_Remember_Call {
	_c.Call.Return(run)
	return _c
}

// RememberForever provides a mock function with given fields: key, callback
func (_m *Repository) RememberForever(key string, callback func() (interface{}, error)) (interface{}, error) {
	ret := _m.Called(key, callback)

	if len(ret) == 0 {
		panic("no return value specified for RememberForever")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, func() (interface{}, error)) (interface{}, error)); ok {
		return rf(key, callback)
	}
	if rf, ok := ret.Get(0).(func(string, func() (interface{}, error)) interface{}); ok {
		r0 = rf(key, callback)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, func() (interface{}, error)) error); ok {
		r1 = rf(key, callback)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_RememberForever_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RememberForever'
type Repository_RememberForever_Call struct {
	*mock.Call
}

// RememberForever is a helper method to define mock.On call
//   - key string
//   - callback func()(interface{} , error)
func (_e *Repository_Expecter) RememberForever(key interface{}, callback interface{}) *Repository_RememberForever_Call {
	return &Repository_RememberForever_Call{Call: _e.mock.On("RememberForever", key, callback)}
}

func (_c *Repository_RememberForever_Call) Run(run func(key string, callback func() (interface{}, error))) *Repository_RememberForever_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func() (interface{}, error)))
	})
	return _c
}

func (_c *Repository_RememberForever_Call) Return(_a0 interface{}, _a1 error) *Repository_RememberForever_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_RememberForever_Call) RunAndReturn(run func(string, func() (interface{}, error)) (interface{}, error)) *Repository_RememberForever_Call {
	_c.Call.Return(run)
	return _c
}

// Tags provides a mock function with given fields: tags
func (_m *Repository) Tags(tags ...string) cache.Repository {
	_va := make([]interface{}, len(tags))
	for _i := range tags {
		_va[_i] = tags[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Tags")
	}

	var r0 cache.Repository
	if rf, ok := ret.Get(0).(func(...string) cache.Repository); ok {
		r0 = rf(tags...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Repository)
		}
	}

	return r0
}

// Repository_Tags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tags'
type Repository_Tags_Call struct {
	*mock.Call
}

// Tags is a helper method to define mock.On call
//   - tags ...string
func (_e *Repository_Expecter) Tags(tags ...interface{}) *Repository_Tags_Call {
	return &Repository_Tags_Call{Call: _e.mock.On("Tags",
		append([]interface{}{}, tags...)...)}
}

func (_c *Repository_Tags_Call) Run(run func(tags ...string)) *Repository_Tags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Repository_Tags_Call) Return(_a0 cache.Repository) *Repository_Tags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Tags_Call) RunAndReturn(run func(...string) cache.Repository) *Repository_Tags_Call {
	_c.Call.Return(run)
	return _c
}

// WithContext provides a mock function with given fields: ctx
func (_m *Repository) WithContext(ctx context.Context) cache.Driver {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithContext")
	}

	var r0 cache.Driver
	if rf, ok := ret.Get(0).(func(context.Context) cache.Driver); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.Driver)
		}
	}

	return r0
}

// Repository_WithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithContext'
type Repository_WithContext_Call struct {
	*mock.Call
}

// WithContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Repository_Expecter) WithContext(ctx interface{}) *Repository_WithContext_Call {
	return &Repository_WithContext_Call{Call: _e.mock.On("WithContext", ctx)}
}

func (_c *Repository_WithContext_Call) Run(run func(ctx context.Context)) *Repository_WithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Repository_WithContext_Call) Return(_a0 cache.Driver) *Repository_WithContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_WithContext_Call) RunAndReturn(run func(context.Context) cache.Driver) *Repository_WithContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
